const { getOmedaCustomerRecord } = require('@mindful-web/marko-web-omeda-identity-x/omeda-data');
const buildSubscriptionEntity = require('@mindful-web/marko-web-identity-x/utils/build-subscription-entity');
const { get, getAsArray } = require('@mindful-web/object-path');
const gql = require('graphql-tag');

/**
 * Returns the first encryped id found (if any) for the supplied email address
 * @param {object} args
 * @param {import("apollo-client").ApolloClient} args.client The Omeda GraphQL client instance
 * @param {string} args.emailAddress The email address to look up
 * @param {number} [args.productId] The Omeda productId to filter the results by
 * @returns {Promise<string?>}
 */
const getEncryptedIdFromEmail = async ({ client, emailAddress }) => {
  const query = gql`
    query CustomersByEmailAddress($emailAddress: String!) {
      customersByEmailAddress(input: {
        emailAddress: $emailAddress
      }) { encryptedCustomerId }
    }
  `;
  const variables = { emailAddress };
  const { data } = await client.query({ query, variables });
  return get(data, 'customersByEmailAddress.0.encryptedCustomerId');
};

const getEncryptedOmedaId = async ({ req, payload }) => {
  const omeda = req.app.locals.site.getAsObject('omeda');
  const { user } = payload;
  const found = getAsArray(user, 'externalIds')
    .find(({ identifier, namespace }) => identifier.type === 'encrypted'
      && namespace.provider === 'omeda'
      && namespace.tenant === omeda.brandKey);
  if (found) return get(found, 'identifier.value');
  // If no external user found attept to retrieve the user's encrypted customer id directly
  return getEncryptedIdFromEmail({
    client: req.$omedaGraphQLClient,
    emailAddress: payload.user.email,
  });
};

/**
 * @param {object} args
 * @param {Request} args.req
 * @param {object} args.payload
 * @returns {Promise<OmedaSubscriptionIdSets>}
 */
const getOmedaSubscriptionIds = async ({ req, payload }) => {
  const userDemoIds = new Set();
  const userDeploymentIds = new Set();
  const userProductIds = new Set();

  const encryptedCustomerId = await getEncryptedOmedaId({ req, payload });
  const omedaCustomer = encryptedCustomerId ? await getOmedaCustomerRecord({
    omedaGraphQLClient: req.$omedaGraphQLClient,
    encryptedCustomerId,
  }) : {};

  getAsArray(omedaCustomer, 'subscriptions')
    .forEach(({ product }) => userProductIds.add(product.id));
  getAsArray(omedaCustomer, 'demographics')
    .forEach(({ demographic }) => userDemoIds.add(demographic.id));
  getAsArray(omedaCustomer, 'primaryEmailAddress.optInStatus')
    .forEach(({ deploymentTypeId }) => userDeploymentIds.add(deploymentTypeId));

  return {
    userDemoIds,
    userDeploymentIds,
    userProductIds,
  };
};

/**
 * Returns a promo code based on the source of the login action
 *
 * @param {RROIDXLoginSource} [loginSource]
 * @param {RROIDXEventData} [data]
 */
const getPromoCodeFor = ({
  loginSource,
  // data = {},
  defaultPromoCode = 'P1',
  promoCodePrefix,
}) => {
  switch (loginSource) {
    case 'newsletterSignup':
      return `${promoCodePrefix}_NL_${defaultPromoCode}`;
      // if (data.newsletterSignupType === 'pushdown') return `${promoCodePrefix}eNLPushdown`;
      // if (data.newsletterSignupType === 'inlineContent') return `${promoCodePrefix}eNLInline`;
      // if (data.newsletterSignupType === 'inlineSection') return `${promoCodePrefix}eNLInline`;
      // if (data.newsletterSignupType === 'footer') return `${promoCodePrefix}eNLFooter`;
      // break;
    // case 'comments':
    //   return `${promoCodePrefix}Comments`;
    // Login originated from the content meter
    // case 'content_meter_login':
    //   // If the overlay was displayed, this is a "metered gate"
    //   if (data.displayOverlay) return `${promoCodePrefix}MeterGate`;
    //   return `${promoCodePrefix}Meter`;
    // Login originated from content that was explicitly gated (requiresRegistration)
    // case 'contentGate':
    //   return `${promoCodePrefix}HardGate`;
    default:
      return `${promoCodePrefix}_${defaultPromoCode}`;
  }
};

module.exports = (args) => {
  const {
    omedaConfig,
    idxConfig,
    rapidIdentProductId,
    websiteBehaviorAttributeId,
    // Passed through, if specified.
    appendPromoCodeToHook = [],
    appendBehaviorToHook = [],
    appendDemographicToHook = [],
    omedaPromoCodePrefix,
    omedaPromoCodeDefault,
    shouldAwait = {
      onLoginLinkSent: true,
    },
  } = args;
  return {
    clientKey: omedaConfig.clientKey,
    brandKey: omedaConfig.brandKey,
    appId: omedaConfig.appId,
    inputId: omedaConfig.inputId,
    rapidIdentProductId,
    idxConfig,
    omedaPromoCodePrefix,
    omedaPromoCodeDefault,
    shouldAwait,
    /**
     * Behavior config is now mandatory and can be generated by the CLI.
     * @see https://github.com/parameter1/identity-x-omeda-cli
     *  */
    behaviors: {
      logIn: 103,
      verifyEmail: 104,
      submitProfile: 105,
    },
    behaviorAttributes: {
      website: {
        id: 8,
        valueId: websiteBehaviorAttributeId,
      },
      actionSource: {
        id: 11,
        valueIds: {
          default: 199623,
          newsletterSignup: 199625,
          comments: 199626,
          contentGate: 199620,
        },
      },
      newsletterSignupType: {
        id: 9,
        valueIds: {
          default: 199617,
          pushdown: 199616,
          inlineContent: 199621,
          inlineSection: 199619,
          footer: 199615,
        },
      },
      contentGateType: {
        id: 10,
        valueIds: {
          default: 199618,
          metered: 199622,
          printPreview: 199624,
        },
      },
    },
    appendPromoCodeToHook,
    appendBehaviorToHook,
    appendDemographicToHook,
    // onLoginLinkSentFormatter: (async ({ req, source, payload }) => {
    //   const { default: defaultPromoCode } = onLoginLinkSentPromoCodes;
    //   const sourcePromoCode = onLoginLinkSentPromoCodes[source];
    //   const { promoCodeCookieName } = omedaConfig;

    //   // if neither are set skip and retun the payload
    //   if (!sourcePromoCode && !defaultPromoCode) return payload;

    //   const val = sourcePromoCode || defaultPromoCode;
    //   const options = { maxAge: 60 * 60 * 24 * 365, httpOnly: false };
    //   req.res.cookie(promoCodeCookieName, val, options);
    //   return {
    //     ...payload,
    //     promoCode: val,
    //   };
    // }),
    onLoginLinkSentFormatter: (async ({
      req,
      payload: data,
      source: loginSource,
      additionalEventData = {},
      user,
    }) => {
      const payload = { ...data, user };

      const { requiresUserInput } = additionalEventData;
      // If the user enters data consider the a profile submit instead of login.
      // update and send matching submit profile instead of login to omeda
      // if (requiresUserInput) payload.behavior.id = 739;

      // BAIL if omedaGraphQLCLient isnt available return payload.
      if (!req.$omedaGraphQLClient) return payload;

      const promoCode = getPromoCodeFor({
        loginSource,
        data: additionalEventData,
        defaultPromoCode: omedaPromoCodeDefault,
        promoCodePrefix: omedaPromoCodePrefix,
      });

      payload.promoCode = promoCode;
      payload.appendPromoCodes = [{ promoCode }];

      /** @type {OIDXOptInHooks} */
      const identityXOptInHooks = req.app.locals.site.getAsObject('identityXOptInHooks') || {};
      if (!identityXOptInHooks.onLoginLinkSent) return payload;

      // Append automatic product subscriptions and deployment opt-ins to OIDX payload
      const {
        demographics,
        deploymentTypeIds,
        productIds,
      } = identityXOptInHooks.onLoginLinkSent || {};

      // const { user } = payload;

      // Use original payload data to avoid altering user record on lookup.
      const {
        userProductIds,
        userDemoIds,
        userDeploymentIds,
      } = (!requiresUserInput)
        ? await getOmedaSubscriptionIds({ req, payload: data })
        : { userProductIds: new Set(), userDemoIds: new Set(), userDeploymentIds: new Set() };

      // Add demos, subscriptions, and opt-ins, excluding any the customer already has
      payload.appendDemographics = (demographics || []).reduce((arr, demo) => {
        if (userDemoIds.has(demo.id)) return arr;
        arr.push({
          demographicId: demo.id,
          valueIds: demo.valueIds || [],
          writeInValue: demo.writeInValue,
        });
        return arr;
      }, []);

      payload.appendSubscriptions = (productIds || []).reduce((arr, value) => {
        const {
          id,
          receive = true,
          requestedVersion,
        } = (typeof value === 'object') ? value : { id: value, receive: true };
        if (userProductIds.has(id)) return arr;
        arr.push({ id, receive, ...(requestedVersion && { requestedVersion }) });
        return arr;
      }, []);

      payload.deploymentTypes = (deploymentTypeIds || []).reduce((arr, id) => {
        if (userDeploymentIds.has(id)) return arr;
        arr.push({ id, optedIn: true });
        return arr;
      }, []);

      const { newsletterSignupType } = additionalEventData;
      // eslint-disable-next-line no-param-reassign
      additionalEventData.autoSignups = payload.deploymentTypes.map(({ id }) => ({
        userId: user.id,
        productId: id,
        promoCode,
        actionSource: loginSource,
        ...(newsletterSignupType && { newsletterSignupType }),
        subscriptionEntity: buildSubscriptionEntity({
          provider: 'omeda',
          tenant: omedaConfig.brandKey,
          type: 'product',
          identifier: id,
        }),
      }));
      return payload;
    }),
  };
};
